<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, content="no-cache", initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<meta name="format-detection" content="telephone=no" />
<title></title>
<link rel="stylesheet" type="text/css" href="css/style.css">
<link rel="stylesheet" type="text/css" href="css/test.css">
<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/js.js" type="text/javascript"></script>
<style type="text/css">
textarea.novel{
	overflow-y: auto;
	min-height: 8.4em;
	line-height: 1.3;
    width: 100%;
    background-color: transparent;
    color: #f8f8f8;
    border: none;
}
</style>
</head>
<body>
	<div class="content">
		<div class="css-wrap">
			<div class="csstitle">React(潜力无上限)</div>
			<div class="cssdetail">
				<p>02-ReactDOM.render()</p>
				<p class="cssdetail-xx">
					案例：ReactDOM.render(标签+内容,document.getElementById('example') );
				</p>
				<p class="cssdetail-xx">说明：ReactDOM.render是React的最基本方法，用于将模板转为HTML语言，并插入指定的DOM节点</p>
				<p>03-JSX语法</p>
				<p class="cssdetail-xx">
					案例：
					<a href="../../4-react/react-demos-master/demo02/index.html" target="_blank">demo02</a>
				</p>
				<p class="cssdetail-xx">
					说明：遇到HTML标签(以/
					< 开头)，就用HTML规则解析;遇到代码块(以{开头),就用Javascript规则解析。</p>
						<p>04-JSX语法：数组</p>
						<p class="cssdetail-xx">
							案例：
							<a href="../../4-react/react-demos-master/demo03/index.html" target="blank">demo03</a>
						</p>
						<p class="cssdetail-xx">说明：JSX允许直接在模板插入JavaScript变量。如果这个变量是一个数组，则会展开这个数组的所有成员</p>
						<p>05-组件</p>
						<p class="cssdetail-xx">
							案例：
							<a href="../../4-react/react-demos-master/demo04/index.html" target="blank">demo04</a>
						</p>
						<p class="cssdetail-xx">
							说明：允许将代码封装成组件，然后像插入普通HTML标签一样，在网页中插入这个组件。React.createClass方法就用于生成一个组件类。
						</p>
						<p>06-this.props.children</p>
						<p class="cssdetail-xx">
							案例：
							<a href="../../4-react/react-demos-master/demo05/index.html" target="blank">demo05</a>
						</p>
						<p class="cssdetail-xx">
							值：1.如果当前组件没有子节点，返回underfined;2.如果有一个子节点，数据类型是object;如果有多个子节点，数据类型就是array
						</p>
						<p class="cssdetail-xx">
							说明：this.props对象的属性与组件的属性一一对应，但是有一个例外，就是this.props.children属性。他表示组建的所有子节点
						</p>
						<p class="cssdetail-xx">遍历：React.Children.map</p>
						<p>07-PropTypes</p>
						<p class="cssdetail-xx">
							案例：
							<a href="../../4-react/react-demos-master/demo06/index.html" target="blank">PropTypes-demo06</a>
						</p>
						<p class="cssdetail-xx">
							说明：this.props对象的属性与组件的属性一一对应，但是有一个例外，就是this.props.children属性。他表示组建的所有子节点
						</p>
						<p>07-1 PropTypes->getDefaultProps</p>
						<p class="cssdetail-xx">作用：用来设置组件属性的默认值</p>
						<p class="cssdetail-xx">
							说明：this.props对象的属性与组件的属性一一对应，但是有一个例外，就是this.props.children属性。他表示组建的所有子节点
						</p>
						<p>08- 获取真实的DOM节点</p>
						<p class="cssdetail-xx">
							案例：
							<a href="../../4-react/react-demos-master/demo07/index.html" target="blank">获取真实的DOM节点-demo07</a>
						</p>
						<p class="cssdetail-xx">
							虚拟DOM：组件并不是真实的DOM节点，而是存在于内存之中的一种数据结构，叫做虚拟DOM。只有当他茶如文档以后，才会变成真实的DOM。
						</p>
						<p>09- this.state</p>
						<p class="cssdetail-xx">
							案例：
							<a href="../../4-react/react-demos-master/demo08/index.html" target="blank">this.state-demo08</a>
						</p>
						<p class="cssdetail-xx">
							说明：当用户点击组件，导致状态变化，this.setState方法就修改状态值，每次修改以后，自动调用this.render方法，再次渲染组件。
						</p>
						<p>10- 表单</p>
						<p class="cssdetail-xx">
							案例：
							<a href="../../4-react/react-demos-master/demo09/index.html" target="blank">this.state-demo09</a>
						</p>
						<p class="cssdetail-xx">
							说明：用户在表单填入的内容，属于用户跟组件的互动，所以不能用this.props读取。textarea、select、radio元素都属于这种情况。
						</p>
						<p>11- 组件的生命周期</p>
						<p class="cssdetail-xx">
							案例：
							<a href="../../4-react/react-demos-master/demo10/index.html" target="blank">this.state-demo10</a>
						</p>
						<p class="cssdetail-xx">
							状态：1.Mounting(已插入真实 DOM);2.Updating(正在被重新渲染);3.Unmounting(已移出真实DOM)
						</p>
						<p class="cssdetail-xx">
							处理函数(will,进入状态之前调用;did函数在进入状态之后调用)：  1.conponentWillMount();
							<br>
							2.compinentDidMount();
							<br>
							3.componentWillUpdate(object nextProps,object prevState);
							<br>
							4.componentDidUpdate(object precProps,object prevState);
							<br>5.componentWillUmmount().</p>
						<p class="cssdetail-xx">componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</p>
						<p class="cssdetail-xx">
							shouldComponentUpdate(object nextProps,object nextState):组件判断是否重新渲染时调用
						</p>
						<p class="cssdetail-xx">
							注意：style={{opacity:this.state.opacity}}，而不能写成style="opacity:{this.state.opacity}"
						</p>
						<p>12- Ajax</p>
						<p class="cssdetail-xx">
							案例：
							<a href="../../4-react/react-demos-master/demo011/index.html" target="blank">this.state-demo011</a>
						</p>
						<p class="cssdetail-xx">
							说明：组件的数据来源，通常是通过Ajax请求从服务器获取，可以使用componentDidMount方法设施Ajax请求，等到请求成功再用this.setState方法重新渲染UI
						</p>
<textarea name="" class="novel">
						 

						 </textarea>
					</div>
				</div>
			</div>
</body>
		</html>